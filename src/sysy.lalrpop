use crate::ast;
grammar;

// Skip whitespace and comments
match {
    r"\s*"=>{},
    r"//[^\n\r]*[\n\r]*"=>{},
    r"/\*(\*[^/]|[^\*])*\*/"=>{},
    _
}

pub CompUnit:ast::CompUnit = {
    FuncDef => ast::CompUnit::FuncDef(<>),
};

FuncDef:ast::FuncDef = {
    <func_type:FuncType> <func_ident:Ident> "(" ")" <block:Block> => ast::FuncDef{<>},
};


FuncType:ast::FuncType = {
    "int" => ast::FuncType::TypeInt,
    "void" => ast::FuncType::TypeVoid,
};  

Block:ast::Block = {
    "{" <BlockItems> "}" => ast::Block::BlockItems(<>),
    "{" "}" => ast::Block::Void,
};

BlockItems:ast::BlockItems = {
    <mut block_items:BlockItems> <block_item:BlockItem> => {
        block_items.push(block_item);
        block_items
    },
    BlockItem => vec![<>],
};

BlockItem:ast::BlockItem = {
    Stmt => ast::BlockItem::Stmt(<>),
};

Stmt:ast::Stmt = {
    RetStmt => ast::Stmt::RetStmt(<>),
};

// RetStmt ::= "return" Exp ";" | "return" ";";
RetStmt:ast::RetStmt = {
    "return" <Exp> ";" => ast::RetStmt::Exp(<>),
    "return" ";" => ast::RetStmt::Void,
};

// Exp ::= LOrExp;
Exp:ast::Exp = {
    LOrExp => ast::Exp{
        l_or_exp: Box::new(<>),
    },
};

// LOrExp ::= LAndExp | LOrExp "||" LAndExp;
LOrExp:ast::LOrExp = {
    LAndExp => ast::LOrExp::LAndExp(<>),
    <l_or_exp:LOrExp> "||" <l_and_exp:LAndExp> =>ast::LOrExp::BinaryOp(Box::new(l_or_exp),l_and_exp),
};

// LAndExp ::= EqExp | LAndExp "&&" EqExp;
LAndExp:ast::LAndExp = {
    EqExp => ast::LAndExp::EqExp(<>),
    <l_and_exp:LAndExp> "&&" <eq_exp:EqExp> => ast::LAndExp::BinaryOp(Box::new(l_and_exp),eq_exp),

};

// EqExp ::= RelExp | EqExp ("==" | "!=") RelExp;
EqExp:ast::EqExp = {
    RelExp => ast::EqExp::RelExp(<>),
    <eq_exp:EqExp> <eq_op:EqOp> <rel_exp:RelExp> => ast::EqExp::BinaryOp(Box::new(eq_exp),eq_op,rel_exp),
};

// EqOp ::= "==" | "!=";
EqOp:ast::Operator = {
    "==" => ast::Operator::Equal,
    "!=" => ast::Operator::NotEqual,
};

// RelExp ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
RelExp:ast::RelExp = {
    AddExp => ast::RelExp::AddExp(<>),
    <rel_exp:RelExp> <rel_op:RelOp> <add_exp:AddExp> => ast::RelExp::BinaryOp(Box::new(rel_exp),rel_op,add_exp),
};

// RelOp ::= "<" | ">" | "<=" | ">=";
RelOp:ast::Operator = {
    "<" => ast::Operator::LessThan,
    ">" => ast::Operator::MoreThan,
    "<=" => ast::Operator::LessOrEqualThan,
    ">=" => ast::Operator::MoreOrEqualThan,
};

// AddExp ::= MulExp | AddExp ("+" | "-") MulExp;
AddExp:ast::AddExp = {
    MulExp => ast::AddExp::MulExp(<>),
    <add_exp:AddExp> <add_op:AddOp> <mul_exp:MulExp> => ast::AddExp::BinaryOp(Box::new(add_exp),add_op,mul_exp),
};

// AddOp ::= "+" | "-";
AddOp:ast::Operator = {
    "+" => ast::Operator::Add,
    "-" => ast::Operator::Subtract,
};

// MulExp ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
MulExp:ast::MulExp = {
    UnaryExp => ast::MulExp::UnaryExp(<>),
    <mul_exp:MulExp> <mul_op:MulOp> <unary_exp:UnaryExp> => ast::MulExp::BinaryOp(Box::new(mul_exp),mul_op,unary_exp),
};

// MulOp ::= "*" | "/" | "%";
MulOp:ast::Operator = {
    "*" => ast::Operator::Multiply,
    "/" => ast::Operator::Divide,
    "%" => ast::Operator::GetRemainder,
};

// Expect: UnaryExp ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
// Now: UnaryExp ::= PrimaryExp | UnaryOp UnaryExp;
UnaryExp:ast::UnaryExp = {
    PrimaryExp => ast::UnaryExp::PrimaryExp(<>),
    <unary_op:UnaryOp> <unary_exp:UnaryExp> => ast::UnaryExp::UnaryOp(unary_op,Box::new(unary_exp)),
};

// UnaryOp ::= "+" | "-" | "!";
UnaryOp:ast::Operator = {
    "+" => ast::Operator::Add,
    "-" => ast::Operator::Subtract,
    "!" => ast::Operator::Not,
};

// Expect: PrimaryExp ::= "(" Exp ")" | LVal | Number;
// Now: PrimaryExp ::= "(" Exp ")" | Number;
PrimaryExp:ast::PrimaryExp = {
    "(" <Exp> ")" => ast::PrimaryExp::Exp(<>),
    Number => ast::PrimaryExp::Number(<>),
};


Ident:String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string(),
};

Number:ast::Number = {
    IntConst => ast::Number::IntConst(<>),
}

IntConst:i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>,10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>,8).unwrap(),
    r"0[xX][0-9A-Fa-f]+" => i32::from_str_radix(&<>[2..],16).unwrap(),
};